package jcog.map;

/**
 * This is an implementation a modular linear probing hash table which
 * dynamically adjusts it's size based on the table density.
 * <p>
 * The table index for a key is a composition of the client supplied Key
 * object hashCode method and internal modular hashing based on table size.
 * In other words, the target table index is computed as h(k) = k mod m
 * where m is the number of table entries and k is the integer hash code
 * generated by the Key object.
 * <p>
 * Collisions are resolved with a linear probing algorithm.  If the target
 * index is located in the top half of the table, the probe will operate
 * from the target index down to the end of the table.  If the target
 * index is located in the bottom half of the table, the probe will operate
 * from the target index up to the beginning of the table.
 * <p>
 * Resizing is performed when objects are added or removed from the table.
 * If adding an object to the table results in a table density greater than
 * the maxim table density; a larger table is created, entries are removed from
 * the existing table and hashed into the larger table, the empty table
 * is replaced with the larger table.  Conversely, when removing an entry from
 * the table results in a table density that is less than the minimum table
 * density; a smaller table is created, entries ar removed from the existing
 * table and hashed into the smaller table, the smaller table replaces the empty
 * table.
 * <p>
 * from: https://raw.githubusercontent.com/graels/LinearProbingHashTable/master/src/com/example/LinearProbingHashTable.java
 *
 * UNTESTED
 */
public final class LinearProbingHashTable<K, V> {

    private final static int MIN_SIZE = 4;         // Minimum table size
    private final static int MIN_DENSITY = 15;     // Minimum table density
    private final static int MAX_DENSITY = 50;     // Maximum table density

    private int mSize;                             // The total number of slots in the table
    private int mCount = 0;                        // The number of entries in the table
    private HashEntry<K, V> mTable[] = null;        // The current table

    /**
     * Internal immutable hash table entry instance
     * <p>
     * The key and value fields of an instance must both be initialized to
     * values other than null or the construction of the instance will fail.
     */
    private static class HashEntry<K, V> {
        private final K key;
        private final V value;

        public HashEntry(K key, V value) throws IllegalArgumentException {
            if (key != null && value != null) {
                this.key = key;
                this.value = value;
            } else {
                throw new IllegalArgumentException("Null arguments are not allowed");
            }
        }
    }

    ///
    ///  Private methods
    ///

    /**
     * Compute a modular table index based on the Key object hashCode and the
     * size of the target table.
     * <p>
     * Must return a positive integer in the range 0-table size.
     *
     * @param key - The key to be hashed
     * @return - positive integer index into the table
     */
    private int hash(K key) {
        return (key.hashCode() & 0x7fffffff) % mSize;
    }

    /**
     * Resize (increase or reduce the size of) the hash table by creating a new
     * table, rehash existing entries from the current table into the new table,
     * removing all entries from the current table and replacing the current table
     * with the new table.
     * <p>
     * The size of the new hash table must be large enough to hold all existing
     * entries, or the resize operation will fail.
     *
     * @param size the target size of the table
     * @throws IllegalArgumentException when the target size is < than the number of table entries
     */
    private void resize(int size) throws IllegalArgumentException {
        int count = 0;
        HashEntry<K, V>[] mTable = this.mTable;

        size = (size > MIN_SIZE) ? size : MIN_SIZE;
        if (size >= mCount) {
            // Create a new table
            LinearProbingHashTable<K, V> table = new LinearProbingHashTable<K, V>(size);
            // Hash the entries from the existing table into the new table;
            for (int i = 0; i < mSize && count < mCount; i++) {
                if (mTable[i] != null) {
                    table.put(mTable[i].key, this.mTable[i].value);
                    count++;
                }
            }
            // Replace the existing table withe the new table
            this.mTable = table.mTable;
            mSize = table.mSize;
        } else {
            throw new IllegalArgumentException("The requested size, " + size + ", is not sufficient for " + mCount + " entries.");
        }
    }

    ///
    ///  Public methods
    ///

    /**
     * Construct an empty table of the minimum size
     */
    public LinearProbingHashTable() {
        this(MIN_SIZE);
    }

    /**
     * Construct an empty array of the requested size
     * <p>
     * Note that there is a minimum size threshold of MIN_SIZE.  A size
     * parameter value that is below this threshold will result in the
     * creation of a table of MIN_SIZE size.
     *
     * @param size a positive integer indicating the initial size of the table
     */
    @SuppressWarnings("unchecked")
    public LinearProbingHashTable(int size) {
        mSize = (size > MIN_SIZE) ? size : MIN_SIZE;
        mTable = new HashEntry[mSize];
    }

    /**
     * Test if the table is empty
     *
     * @return true if the table contains 0 entries, or false
     */
    public boolean isEmpty() {
        return mCount == 0;
    }

    /**
     * Determine the current size of this table instance
     * <p>
     * * @return the current size of the table
     */
    public int size() {
        return mSize;
    }

    /**
     * Compute the the current density of this table instance
     *
     * @return the percent of the table that contains entries
     */
    public int density() {
        int rv = 0;
        if (mCount > 0) {
            rv = (mCount * 100) / mSize;
        }
        return rv;
    }

    /**
     * Insert a new non null key value pair into the table.
     * <p>
     * The size of the table will dynamically increased if the MAX_DENSITY
     * threshold has been crossed.
     * <p>
     * The mCount member will be incremented if an entry is added to the table.
     *
     * @param key   a non-null Key object
     * @param value d non-null Value object
     * @return return true if a new entry was inserted into the table, or false
     * @throws InternalError when the attempt to resize the table fails
     */
    public boolean put(K key, V value) {
        boolean insert = false;

        if (key != null && value != null) {

            // Resize if the table has reached the maximum density
            if (density() >= MAX_DENSITY) {
                try {
                    resize(mSize * 2);
                } catch (IllegalArgumentException e) {
                    throw new InternalError("Failed to increase the size of the table");
                }
            }

            // Compute the target index
            int index = hash(key);

            // If the target index is at the top of the table 
            // probe towards the bottom of the table if a collision occurs
            if (index < mSize / 2) {
                while (index < mSize) {
                    if (mTable[index] == null) {
                        insert = true;
                        break;
                    } else {
                        index++;
                    }
                }
            }
            // else, probe towards the top of the table if a collision occurs
            else {
                while (index >= 0) {
                    if (mTable[index] == null) {
                        insert = true;
                        break;
                    } else {
                        index--;
                    }
                }
            }

            // A slot was available so insert the new entry
            if (insert) {
                mTable[index] = new HashEntry<K, V>(key, value);
                mCount++;
            }
        }
        return insert;
    }

    /**
     * Search the table for the specified key, and return the associated
     * Value object if the key is present;
     *
     * @param key the search key
     * @return a V object if the key is found, or null
     */
    public V get(K key) {
        V found = null;

        if (key != null && mCount > 0) {
            return mTable[find(key, found)].value;
        }

        return found;
    }

    public int find(K key, V found) {
        int index = hash(key);
        // If the target index is at the top of the table
        // probe towards the bottom of the table to resolve collisions
        // else, probe towards the top of the table to resolve collisions
        HashEntry<K, V>[] mTable = this.mTable;
        boolean up = (index < mSize / 2);
        while ((up && (index < mSize)) || (!up && (index >= 0))) {
            HashEntry<K, V> mi = mTable[index];
            if (mi != null && mi.key.equals(key)) {
                return index;
            } else {
                index += up ? 1 : -1;
            }
        }
        return index;
    }

    /**
     * Remove the Key and associated Value objects from the table.
     * <p>
     * The size of this instance will dynamically decrease if the MIN_DENSITY
     * threshold has been crossed by removing the entry.
     * <p>
     * The mCount will be decreased if a table entry is removed.
     *
     * @param key a search key
     * @return true if the Key and associated Value objects were removed, or false
     * @throws InternalError when the attempt to resize the table fails
     */
    public boolean remove(K key) throws InternalError {
        boolean remove = false;

        if (key != null && mCount > 0) {
            // Compute the target index
            int index = hash(key);

            // If the target index is at the top of the table
            // probe towards the bottom of the table to resolve collisions
            if (index < mSize / 2) {
                while (index < mSize) {
                    if (mTable[index] != null && mTable[index].key.equals(key)) {
                        remove = true;
                        break;
                    } else {
                        index++;
                    }
                }
            }
            // else, probe towards the top of the table to resolve collisions
            else {
                while (index >= 0) {
                    if (mTable[index] != null && mTable[index].key.equals(key)) {
                        remove = true;
                        break;
                    } else {
                        index--;
                    }
                }
            }

            // If the key was found, remove it from the table
            if (remove) {
                mCount--;
                mTable[index] = null;

                // Resize if the table has reached the minimum density
                if (density() < MIN_DENSITY) {
                    try {
                        resize(mSize / 2);
                    } catch (IllegalArgumentException e) {
                        throw new InternalError("Failed to reduce the size of the table");
                    }
                }
            }
        }

        return remove;
    }
}