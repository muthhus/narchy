<!DOCTYPE html>

<!--<div id="info">-->
<!--<a href="http://threejs.org" target="_blank">three.js</a> webgl - buffergeometry drawcalls - by <a-->
<!--href="https://twitter.com/fernandojsg">fernandojsg</a>-->
<!--</div>-->

<html lang="en">
<head>
    <title>three.js webgl - buffergeometry - lines drawcalls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        html, body, #view, #blocker {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: absolute;
            top: 0px;
            left: 0px;
        }

        body {
            color: #cccccc;
            font-family: Monospace;
            background-color: #000000;
            margin: 0px;
        }

        a {
            color: #0080ff;
        }

    </style>
</head>
<body>






<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.5/dat.gui.min.js"></script>
<script src="http://threejs.org/build/three.min.js"></script>
<script src="http://jeromeetienne.github.io/threex.htmlmixer/threex.htmlmixer.js"></script>
<!--view-source:http://jeromeetienne.github.io/threex.htmlmixer/examples/basic.html -->

<!--<script src="js/libs/stats.min.js"></script>-->


<script>
    /**
     * Based on http://www.emagix.net/academic/mscs-project/item/camera-sync-with-css3-and-webgl-threejs
     * @author mrdoob / http://mrdoob.com/
     */

    THREE.CSS3DObject = function (element) {

        THREE.Object3D.call(this);

        this.element = element;
        this.element.style.position = 'absolute';

        this.addEventListener('removed', function () {

            if (this.element.parentNode !== null) {

                this.element.parentNode.removeChild(this.element);

            }

        });

    };

    THREE.CSS3DObject.prototype = Object.create(THREE.Object3D.prototype);
    THREE.CSS3DObject.prototype.constructor = THREE.CSS3DObject;

    THREE.CSS3DSprite = function (element) {

        THREE.CSS3DObject.call(this, element);

    };

    THREE.CSS3DSprite.prototype = Object.create(THREE.CSS3DObject.prototype);
    THREE.CSS3DSprite.prototype.constructor = THREE.CSS3DSprite;

    //

    THREE.CSS3DRenderer = function () {

        console.log('THREE.CSS3DRenderer', THREE.REVISION);

        var _width, _height;
        var _widthHalf, _heightHalf;

        var matrix = new THREE.Matrix4();

        var cache = {
            camera: {fov: 0, style: ''},
            objects: {}
        };

        var domElement = document.createElement('div');
        domElement.style.overflow = 'hidden';

        this.domElement = domElement;

        var cameraElement = document.createElement('div');

        cameraElement.style.WebkitTransformStyle = 'preserve-3d';
        cameraElement.style.MozTransformStyle = 'preserve-3d';
        cameraElement.style.transformStyle = 'preserve-3d';

        domElement.appendChild(cameraElement);

        var isIE = /Trident/i.test(navigator.userAgent);

        this.setClearColor = function () {
        };

        this.getSize = function () {

            return {
                width: _width,
                height: _height
            };

        };

        this.setSize = function (width, height) {

            _width = width;
            _height = height;
            _widthHalf = _width / 2;
            _heightHalf = _height / 2;

            domElement.style.width = width + 'px';
            domElement.style.height = height + 'px';

            cameraElement.style.width = width + 'px';
            cameraElement.style.height = height + 'px';

        };

        function epsilon(value) {

            return Math.abs(value) < 1e-10 ? 0 : value;

        }

        function getCameraCSSMatrix(matrix) {

            var elements = matrix.elements;

            return 'matrix3d(' +
                epsilon(elements[0]) + ',' +
                epsilon(-elements[1]) + ',' +
                epsilon(elements[2]) + ',' +
                epsilon(elements[3]) + ',' +
                epsilon(elements[4]) + ',' +
                epsilon(-elements[5]) + ',' +
                epsilon(elements[6]) + ',' +
                epsilon(elements[7]) + ',' +
                epsilon(elements[8]) + ',' +
                epsilon(-elements[9]) + ',' +
                epsilon(elements[10]) + ',' +
                epsilon(elements[11]) + ',' +
                epsilon(elements[12]) + ',' +
                epsilon(-elements[13]) + ',' +
                epsilon(elements[14]) + ',' +
                epsilon(elements[15]) +
                ')';

        }

        function getObjectCSSMatrix(matrix, cameraCSSMatrix) {

            var elements = matrix.elements;
            var matrix3d = 'matrix3d(' +
                epsilon(elements[0]) + ',' +
                epsilon(elements[1]) + ',' +
                epsilon(elements[2]) + ',' +
                epsilon(elements[3]) + ',' +
                epsilon(-elements[4]) + ',' +
                epsilon(-elements[5]) + ',' +
                epsilon(-elements[6]) + ',' +
                epsilon(-elements[7]) + ',' +
                epsilon(elements[8]) + ',' +
                epsilon(elements[9]) + ',' +
                epsilon(elements[10]) + ',' +
                epsilon(elements[11]) + ',' +
                epsilon(elements[12]) + ',' +
                epsilon(elements[13]) + ',' +
                epsilon(elements[14]) + ',' +
                epsilon(elements[15]) +
                ')';

            if (isIE) {

                return 'translate(-50%,-50%)' +
                    'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)' +
                    cameraCSSMatrix +
                    matrix3d;

            }

            return 'translate(-50%,-50%)' + matrix3d;

        }

        function renderObject(object, camera, cameraCSSMatrix) {

            if (object instanceof THREE.CSS3DObject) {

                var style;

                if (object instanceof THREE.CSS3DSprite) {

                    // http://swiftcoder.wordpress.com/2008/11/25/constructing-a-billboard-matrix/

                    matrix.copy(camera.matrixWorldInverse);
                    matrix.transpose();
                    matrix.copyPosition(object.matrixWorld);
                    matrix.scale(object.scale);

                    matrix.elements[3] = 0;
                    matrix.elements[7] = 0;
                    matrix.elements[11] = 0;
                    matrix.elements[15] = 1;

                    style = getObjectCSSMatrix(matrix, cameraCSSMatrix);

                } else {

                    style = getObjectCSSMatrix(object.matrixWorld, cameraCSSMatrix);

                }

                var element = object.element;
                var cachedStyle = cache.objects[object.id] && cache.objects[object.id].style;

                if (cachedStyle === undefined || cachedStyle !== style) {

                    element.style.WebkitTransform = style;
                    element.style.MozTransform = style;
                    element.style.transform = style;

                    cache.objects[object.id] = {style: style};

                    if (isIE) {

                        cache.objects[object.id].distanceToCameraSquared = getDistanceToSquared(camera, object);

                    }

                }

                if (element.parentNode !== cameraElement) {

                    cameraElement.appendChild(element);

                }

            }

            for (var i = 0, l = object.children.length; i < l; i++) {

                renderObject(object.children[i], camera, cameraCSSMatrix);

            }

        }

        var getDistanceToSquared = function () {

            var a = new THREE.Vector3();
            var b = new THREE.Vector3();

            return function (object1, object2) {

                a.setFromMatrixPosition(object1.matrixWorld);
                b.setFromMatrixPosition(object2.matrixWorld);

                return a.distanceToSquared(b);

            };

        }();

        function zOrder(scene) {

            var order = Object.keys(cache.objects).sort(function (a, b) {

                return cache.objects[a].distanceToCameraSquared - cache.objects[b].distanceToCameraSquared;

            });
            var zMax = order.length;

            scene.traverse(function (object) {

                var index = order.indexOf(object.id + '');

                if (index !== -1) {

                    object.element.style.zIndex = zMax - index;

                }

            });

        }

        this.render = function (scene, camera) {

            var fov = 0.5 / Math.tan(THREE.Math.degToRad(camera.getEffectiveFOV() * 0.5)) * _height;

            if (cache.camera.fov !== fov) {

                domElement.style.WebkitPerspective = fov + 'px';
                domElement.style.MozPerspective = fov + 'px';
                domElement.style.perspective = fov + 'px';

                cache.camera.fov = fov;

            }

            scene.updateMatrixWorld();

            if (camera.parent === null) camera.updateMatrixWorld();

            camera.matrixWorldInverse.getInverse(camera.matrixWorld);

            var cameraCSSMatrix = 'translateZ(' + fov + 'px)' +
                getCameraCSSMatrix(camera.matrixWorldInverse);

            var style = cameraCSSMatrix +
                'translate(' + _widthHalf + 'px,' + _heightHalf + 'px)';

            if (cache.camera.style !== style && !isIE) {

                cameraElement.style.WebkitTransform = style;
                cameraElement.style.MozTransform = style;
                cameraElement.style.transform = style;

                cache.camera.style = style;

            }

            renderObject(scene, camera, cameraCSSMatrix);

            if (isIE) {

                // IE10 and 11 does not support 'preserve-3d'.
                // Thus, z-order in 3D will not work.
                // We have to calc z-order manually and set CSS z-index for IE.
                // FYI: z-index can't handle object intersection
                zOrder(scene);

            }

        };

    };

    /**
     * @author qiao / https://github.com/qiao
     * @author mrdoob / http://mrdoob.com
     * @author alteredq / http://alteredqualia.com/
     * @author WestLangley / http://github.com/WestLangley
     * @author erich666 / http://erichaines.com
     */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finger swipe

    THREE.OrbitControls = function (object, domElement) {

        this.object = object;

        this.domElement = ( domElement !== undefined ) ? domElement : document;

        // Set to false to disable this control
        this.enabled = true;

        // "target" sets the location of focus, where the object orbits around
        this.target = new THREE.Vector3();

        // How far you can dolly in and out ( PerspectiveCamera only )
        this.minDistance = 0;
        this.maxDistance = Infinity;

        // How far you can zoom in and out ( OrthographicCamera only )
        this.minZoom = 0;
        this.maxZoom = Infinity;

        // How far you can orbit vertically, upper and lower limits.
        // Range is 0 to Math.PI radians.
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians

        // How far you can orbit horizontally, upper and lower limits.
        // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
        this.minAzimuthAngle = -Infinity; // radians
        this.maxAzimuthAngle = Infinity; // radians

        // Set to true to enable damping (inertia)
        // If damping is enabled, you must call controls.update() in your animation loop
        this.enableDamping = false;
        this.dampingFactor = 0.25;

        // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
        // Set to false to disable zooming
        this.enableZoom = true;
        this.zoomSpeed = 1.0;

        // Set to false to disable rotating
        this.enableRotate = true;
        this.rotateSpeed = 1.0;

        // Set to false to disable panning
        this.enablePan = true;
        this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

        // Set to true to automatically rotate around the target
        // If auto-rotate is enabled, you must call controls.update() in your animation loop
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

        // Set to false to disable use of the keys
        this.enableKeys = true;

        // The four arrow keys
        this.keys = {LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40};

        // Mouse buttons
        this.mouseButtons = {ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT};

        // for reset
        this.target0 = this.target.clone();
        this.position0 = this.object.position.clone();
        this.zoom0 = this.object.zoom;

        //
        // public methods
        //

        this.getPolarAngle = function () {

            return spherical.phi;

        };

        this.getAzimuthalAngle = function () {

            return spherical.theta;

        };

        this.saveState = function () {

            scope.target0.copy(scope.target);
            scope.position0.copy(scope.object.position);
            scope.zoom0 = scope.object.zoom;

        };

        this.reset = function () {

            scope.target.copy(scope.target0);
            scope.object.position.copy(scope.position0);
            scope.object.zoom = scope.zoom0;

            scope.object.updateProjectionMatrix();
            scope.dispatchEvent(changeEvent);

            scope.update();

            state = STATE.NONE;

        };

        // this method is exposed, but perhaps it would be better if we can make it private...
        this.update = function () {

            var offset = new THREE.Vector3();

            // so camera.up is the orbit axis
            var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
            var quatInverse = quat.clone().inverse();

            var lastPosition = new THREE.Vector3();
            var lastQuaternion = new THREE.Quaternion();

            return function update() {

                var position = scope.object.position;

                offset.copy(position).sub(scope.target);

                // rotate offset to "y-axis-is-up" space
                offset.applyQuaternion(quat);

                // angle from z-axis around y-axis
                spherical.setFromVector3(offset);

                if (scope.autoRotate && state === STATE.NONE) {

                    rotateLeft(getAutoRotationAngle());

                }

                spherical.theta += sphericalDelta.theta;
                spherical.phi += sphericalDelta.phi;

                // restrict theta to be between desired limits
                spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));

                // restrict phi to be between desired limits
                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));

                spherical.makeSafe();


                spherical.radius *= scale;

                // restrict radius to be between desired limits
                spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));

                // move target to panned location
                scope.target.add(panOffset);

                offset.setFromSpherical(spherical);

                // rotate offset back to "camera-up-vector-is-up" space
                offset.applyQuaternion(quatInverse);

                position.copy(scope.target).add(offset);

                scope.object.lookAt(scope.target);

                if (scope.enableDamping === true) {

                    sphericalDelta.theta *= ( 1 - scope.dampingFactor );
                    sphericalDelta.phi *= ( 1 - scope.dampingFactor );

                } else {

                    sphericalDelta.set(0, 0, 0);

                }

                scale = 1;
                panOffset.set(0, 0, 0);

                // update condition is:
                // min(camera displacement, camera rotation in radians)^2 > EPS
                // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                if (zoomChanged ||
                    lastPosition.distanceToSquared(scope.object.position) > EPS ||
                    8 * ( 1 - lastQuaternion.dot(scope.object.quaternion) ) > EPS) {

                    scope.dispatchEvent(changeEvent);

                    lastPosition.copy(scope.object.position);
                    lastQuaternion.copy(scope.object.quaternion);
                    zoomChanged = false;

                    return true;

                }

                return false;

            };

        }();

        this.dispose = function () {

            scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
            scope.domElement.removeEventListener('mousedown', onMouseDown, false);
            scope.domElement.removeEventListener('wheel', onMouseWheel, false);

            scope.domElement.removeEventListener('touchstart', onTouchStart, false);
            scope.domElement.removeEventListener('touchend', onTouchEnd, false);
            scope.domElement.removeEventListener('touchmove', onTouchMove, false);

            document.removeEventListener('mousemove', onMouseMove, false);
            document.removeEventListener('mouseup', onMouseUp, false);

            window.removeEventListener('keydown', onKeyDown, false);

            //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

        };

        //
        // internals
        //

        var scope = this;

        var changeEvent = {type: 'change'};
        var startEvent = {type: 'start'};
        var endEvent = {type: 'end'};

        var STATE = {NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5};

        var state = STATE.NONE;

        var EPS = 0.000001;

        // current position in spherical coordinates
        var spherical = new THREE.Spherical();
        var sphericalDelta = new THREE.Spherical();

        var scale = 1;
        var panOffset = new THREE.Vector3();
        var zoomChanged = false;

        var rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();

        var panStart = new THREE.Vector2();
        var panEnd = new THREE.Vector2();
        var panDelta = new THREE.Vector2();

        var dollyStart = new THREE.Vector2();
        var dollyEnd = new THREE.Vector2();
        var dollyDelta = new THREE.Vector2();

        function getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }

        function getZoomScale() {

            return Math.pow(0.95, scope.zoomSpeed);

        }

        function rotateLeft(angle) {

            sphericalDelta.theta -= angle;

        }

        function rotateUp(angle) {

            sphericalDelta.phi -= angle;

        }

        var panLeft = function () {

            var v = new THREE.Vector3();

            return function panLeft(distance, objectMatrix) {

                v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
                v.multiplyScalar(-distance);

                panOffset.add(v);

            };

        }();

        var panUp = function () {

            var v = new THREE.Vector3();

            return function panUp(distance, objectMatrix) {

                v.setFromMatrixColumn(objectMatrix, 1); // get Y column of objectMatrix
                v.multiplyScalar(distance);

                panOffset.add(v);

            };

        }();

        // deltaX and deltaY are in pixels; right and down are positive
        var pan = function () {

            var offset = new THREE.Vector3();

            return function pan(deltaX, deltaY) {

                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                if (scope.object instanceof THREE.PerspectiveCamera) {

                    // perspective
                    var position = scope.object.position;
                    offset.copy(position).sub(scope.target);
                    var targetDistance = offset.length();

                    // half of the fov is center to top of screen
                    targetDistance *= Math.tan(( scope.object.fov / 2 ) * Math.PI / 180.0);

                    // we actually don't use screenWidth, since perspective camera is fixed to screen height
                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);

                } else if (scope.object instanceof THREE.OrthographicCamera) {

                    // orthographic
                    panLeft(deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix);
                    panUp(deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix);

                } else {

                    // camera neither orthographic nor perspective
                    console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
                    scope.enablePan = false;

                }

            };

        }();

        function dollyIn(dollyScale) {

            if (scope.object instanceof THREE.PerspectiveCamera) {

                scale /= dollyScale;

            } else if (scope.object instanceof THREE.OrthographicCamera) {

                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;

            } else {

                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
                scope.enableZoom = false;

            }

        }

        function dollyOut(dollyScale) {

            if (scope.object instanceof THREE.PerspectiveCamera) {

                scale *= dollyScale;

            } else if (scope.object instanceof THREE.OrthographicCamera) {

                scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
                scope.object.updateProjectionMatrix();
                zoomChanged = true;

            } else {

                console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
                scope.enableZoom = false;

            }

        }

        //
        // event callbacks - update the object state
        //

        function handleMouseDownRotate(event) {

            //console.log( 'handleMouseDownRotate' );

            rotateStart.set(event.clientX, event.clientY);

        }

        function handleMouseDownDolly(event) {

            //console.log( 'handleMouseDownDolly' );

            dollyStart.set(event.clientX, event.clientY);

        }

        function handleMouseDownPan(event) {

            //console.log( 'handleMouseDownPan' );

            panStart.set(event.clientX, event.clientY);

        }

        function handleMouseMoveRotate(event) {

            //console.log( 'handleMouseMoveRotate' );

            rotateEnd.set(event.clientX, event.clientY);
            rotateDelta.subVectors(rotateEnd, rotateStart);

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            // rotating across whole screen goes 360 degrees around
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

            // rotating up and down along whole screen attempts to go 360, but limited to 180
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

            rotateStart.copy(rotateEnd);

            scope.update();

        }

        function handleMouseMoveDolly(event) {

            //console.log( 'handleMouseMoveDolly' );

            dollyEnd.set(event.clientX, event.clientY);

            dollyDelta.subVectors(dollyEnd, dollyStart);

            if (dollyDelta.y > 0) {

                dollyIn(getZoomScale());

            } else if (dollyDelta.y < 0) {

                dollyOut(getZoomScale());

            }

            dollyStart.copy(dollyEnd);

            scope.update();

        }

        function handleMouseMovePan(event) {

            //console.log( 'handleMouseMovePan' );

            panEnd.set(event.clientX, event.clientY);

            panDelta.subVectors(panEnd, panStart);

            pan(panDelta.x, panDelta.y);

            panStart.copy(panEnd);

            scope.update();

        }

        function handleMouseUp(event) {

            // console.log( 'handleMouseUp' );

        }

        function handleMouseWheel(event) {

            // console.log( 'handleMouseWheel' );

            if (event.deltaY < 0) {

                dollyOut(getZoomScale());

            } else if (event.deltaY > 0) {

                dollyIn(getZoomScale());

            }

            scope.update();

        }

        function handleKeyDown(event) {

            //console.log( 'handleKeyDown' );

            switch (event.keyCode) {

                case scope.keys.UP:
                    pan(0, scope.keyPanSpeed);
                    scope.update();
                    break;

                case scope.keys.BOTTOM:
                    pan(0, -scope.keyPanSpeed);
                    scope.update();
                    break;

                case scope.keys.LEFT:
                    pan(scope.keyPanSpeed, 0);
                    scope.update();
                    break;

                case scope.keys.RIGHT:
                    pan(-scope.keyPanSpeed, 0);
                    scope.update();
                    break;

            }

        }

        function handleTouchStartRotate(event) {

            //console.log( 'handleTouchStartRotate' );

            rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);

        }

        function handleTouchStartDolly(event) {

            //console.log( 'handleTouchStartDolly' );

            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;

            var distance = Math.sqrt(dx * dx + dy * dy);

            dollyStart.set(0, distance);

        }

        function handleTouchStartPan(event) {

            //console.log( 'handleTouchStartPan' );

            panStart.set(event.touches[0].pageX, event.touches[0].pageY);

        }

        function handleTouchMoveRotate(event) {

            //console.log( 'handleTouchMoveRotate' );

            rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
            rotateDelta.subVectors(rotateEnd, rotateStart);

            var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

            // rotating across whole screen goes 360 degrees around
            rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

            // rotating up and down along whole screen attempts to go 360, but limited to 180
            rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

            rotateStart.copy(rotateEnd);

            scope.update();

        }

        function handleTouchMoveDolly(event) {

            //console.log( 'handleTouchMoveDolly' );

            var dx = event.touches[0].pageX - event.touches[1].pageX;
            var dy = event.touches[0].pageY - event.touches[1].pageY;

            var distance = Math.sqrt(dx * dx + dy * dy);

            dollyEnd.set(0, distance);

            dollyDelta.subVectors(dollyEnd, dollyStart);

            if (dollyDelta.y > 0) {

                dollyOut(getZoomScale());

            } else if (dollyDelta.y < 0) {

                dollyIn(getZoomScale());

            }

            dollyStart.copy(dollyEnd);

            scope.update();

        }

        function handleTouchMovePan(event) {

            //console.log( 'handleTouchMovePan' );

            panEnd.set(event.touches[0].pageX, event.touches[0].pageY);

            panDelta.subVectors(panEnd, panStart);

            pan(panDelta.x, panDelta.y);

            panStart.copy(panEnd);

            scope.update();

        }

        function handleTouchEnd(event) {

            //console.log( 'handleTouchEnd' );

        }

        //
        // event handlers - FSM: listen for events and reset state
        //

        function onMouseDown(event) {

            if (scope.enabled === false) return;

            event.preventDefault();

            switch (event.button) {

                case scope.mouseButtons.ORBIT:

                    if (scope.enableRotate === false) return;

                    handleMouseDownRotate(event);

                    state = STATE.ROTATE;

                    break;

                case scope.mouseButtons.ZOOM:

                    if (scope.enableZoom === false) return;

                    handleMouseDownDolly(event);

                    state = STATE.DOLLY;

                    break;

                case scope.mouseButtons.PAN:

                    if (scope.enablePan === false) return;

                    handleMouseDownPan(event);

                    state = STATE.PAN;

                    break;

            }

            if (state !== STATE.NONE) {

                document.addEventListener('mousemove', onMouseMove, false);
                document.addEventListener('mouseup', onMouseUp, false);

                scope.dispatchEvent(startEvent);

            }

        }

        function onMouseMove(event) {

            if (scope.enabled === false) return;

            event.preventDefault();

            switch (state) {

                case STATE.ROTATE:

                    if (scope.enableRotate === false) return;

                    handleMouseMoveRotate(event);

                    break;

                case STATE.DOLLY:

                    if (scope.enableZoom === false) return;

                    handleMouseMoveDolly(event);

                    break;

                case STATE.PAN:

                    if (scope.enablePan === false) return;

                    handleMouseMovePan(event);

                    break;

            }

        }

        function onMouseUp(event) {

            if (scope.enabled === false) return;

            handleMouseUp(event);

            document.removeEventListener('mousemove', onMouseMove, false);
            document.removeEventListener('mouseup', onMouseUp, false);

            scope.dispatchEvent(endEvent);

            state = STATE.NONE;

        }

        function onMouseWheel(event) {

            if (scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE )) return;

            event.preventDefault();
            event.stopPropagation();

            handleMouseWheel(event);

            scope.dispatchEvent(startEvent); // not sure why these are here...
            scope.dispatchEvent(endEvent);

        }

        function onKeyDown(event) {

            if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;

            handleKeyDown(event);

        }

        function onTouchStart(event) {

            if (scope.enabled === false) return;

            switch (event.touches.length) {

                case 1:	// one-fingered touch: rotate

                    if (scope.enableRotate === false) return;

                    handleTouchStartRotate(event);

                    state = STATE.TOUCH_ROTATE;

                    break;

                case 2:	// two-fingered touch: dolly

                    if (scope.enableZoom === false) return;

                    handleTouchStartDolly(event);

                    state = STATE.TOUCH_DOLLY;

                    break;

                case 3: // three-fingered touch: pan

                    if (scope.enablePan === false) return;

                    handleTouchStartPan(event);

                    state = STATE.TOUCH_PAN;

                    break;

                default:

                    state = STATE.NONE;

            }

            if (state !== STATE.NONE) {

                scope.dispatchEvent(startEvent);

            }

        }

        function onTouchMove(event) {

            if (scope.enabled === false) return;

            event.preventDefault();
            event.stopPropagation();

            switch (event.touches.length) {

                case 1: // one-fingered touch: rotate

                    if (scope.enableRotate === false) return;
                    if (state !== STATE.TOUCH_ROTATE) return; // is this needed?...

                    handleTouchMoveRotate(event);

                    break;

                case 2: // two-fingered touch: dolly

                    if (scope.enableZoom === false) return;
                    if (state !== STATE.TOUCH_DOLLY) return; // is this needed?...

                    handleTouchMoveDolly(event);

                    break;

                case 3: // three-fingered touch: pan

                    if (scope.enablePan === false) return;
                    if (state !== STATE.TOUCH_PAN) return; // is this needed?...

                    handleTouchMovePan(event);

                    break;

                default:

                    state = STATE.NONE;

            }

        }

        function onTouchEnd(event) {

            if (scope.enabled === false) return;

            handleTouchEnd(event);

            scope.dispatchEvent(endEvent);

            state = STATE.NONE;

        }

        function onContextMenu(event) {

            event.preventDefault();

        }

        //

        scope.domElement.addEventListener('contextmenu', onContextMenu, false);

        scope.domElement.addEventListener('mousedown', onMouseDown, false);
        scope.domElement.addEventListener('wheel', onMouseWheel, false);

        scope.domElement.addEventListener('touchstart', onTouchStart, false);
        scope.domElement.addEventListener('touchend', onTouchEnd, false);
        scope.domElement.addEventListener('touchmove', onTouchMove, false);

        window.addEventListener('keydown', onKeyDown, false);

        // force an update at start

        this.update();

    };

    THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
    THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;

    Object.defineProperties(THREE.OrbitControls.prototype, {

        center: {

            get: function () {

                console.warn('THREE.OrbitControls: .center has been renamed to .target');
                return this.target;

            }

        },

        // backward compatibility

        noZoom: {

            get: function () {

                console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
                return !this.enableZoom;

            },

            set: function (value) {

                console.warn('THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
                this.enableZoom = !value;

            }

        },

        noRotate: {

            get: function () {

                console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
                return !this.enableRotate;

            },

            set: function (value) {

                console.warn('THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
                this.enableRotate = !value;

            }

        },

        noPan: {

            get: function () {

                console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
                return !this.enablePan;

            },

            set: function (value) {

                console.warn('THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
                this.enablePan = !value;

            }

        },

        noKeys: {

            get: function () {

                console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
                return !this.enableKeys;

            },

            set: function (value) {

                console.warn('THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
                this.enableKeys = !value;

            }

        },

        staticMoving: {

            get: function () {

                console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
                return !this.enableDamping;

            },

            set: function (value) {

                console.warn('THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
                this.enableDamping = !value;

            }

        },

        dynamicDampingFactor: {

            get: function () {

                console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
                return this.dampingFactor;

            },

            set: function (value) {

                console.warn('THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
                this.dampingFactor = value;

            }

        }

    });


</script>


<script>


    var nodeData = [];
    var nodes;
    var nodePos;

    //var pointCloud;
    var edgeMesh;

    var maxParticleCount = 1000;
    var particleCount = 500;
    var r = 800;
    var rHalf = r / 2;

    var effectController = {
        showDots: true,
        showLines: true,
        minDistance: 150,
        limitConnections: false,
        maxConnections: 20,
        particleCount: 500
    };

    initGUI();


    const view =
        document.body;
        //document.getElementById('view');

//    const blocker = document.getElementById('blocker');
//    blocker.style.display = 'none';
//    view.addEventListener('mousedown', () => {
//        blocker.style.display = '';
//    });
//    view.addEventListener('mouseup', () => {
//        blocker.style.display = 'none';
//    });

    const options = {alpha: true, antialias: false};

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
    camera.position.z = 1750;

    const controls = new THREE.OrbitControls(camera, view);

    const groupGL = new THREE.Group();
    const sceneGL = new THREE.Scene();
    sceneGL.add(groupGL);



    var helper = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r, r, r)));
    helper.material.color.setHex(0x080808);
    helper.material.blending = THREE.AdditiveBlending;
    helper.material.transparent = true;
    groupGL.add(helper);

    var segments = maxParticleCount * maxParticleCount;

    var POS = new Float32Array(segments * 3);
    var COLOR = new Float32Array(segments * 3);

    var pMaterial = new THREE.PointsMaterial({
        color: 0xFFFFFF,
        size: 3,
        blending: THREE.AdditiveBlending,
        transparent: true,
        sizeAttenuation: false
    });
    var material = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        blending: THREE.AdditiveBlending,
        transparent: true
    });

    nodes = new THREE.BufferGeometry();
    nodePos = new Float32Array(maxParticleCount * 3);
    for (var i = 0; i < maxParticleCount; i++) {
        var x = Math.random() * r - r / 2;
        var y = Math.random() * r - r / 2;
        var z = Math.random() * r - r / 2;
        nodePos[i * 3] = x;
        nodePos[i * 3 + 1] = y;
        nodePos[i * 3 + 2] = z;
        // add it to the geometry
        nodeData.push({
            vel: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2),
            arity: 0
        });
    }
    nodes.setDrawRange(0, particleCount);
    nodes.addAttribute('position', new THREE.BufferAttribute(nodePos, 3).setDynamic(true));


    //groupGL.add(pointCloud = new THREE.Points(nodes, pMaterial));


    var geometry = new THREE.BufferGeometry();
    geometry.addAttribute('position', new THREE.BufferAttribute(POS, 3).setDynamic(true));
    geometry.addAttribute('color', new THREE.BufferAttribute(COLOR, 3).setDynamic(true));
    geometry.computeBoundingSphere();
    geometry.setDrawRange(0, 0);

    edgeMesh = new THREE.LineSegments(geometry, material);
    groupGL.add(edgeMesh);


    const rendererGL = new THREE.WebGLRenderer(options);
    rendererGL.autoClear = false;
    rendererGL.setClearColor(0x00ff00, 0.0);
    rendererGL.setPixelRatio(window.devicePixelRatio);
    rendererGL.gammaInput = true;
    rendererGL.gammaOutput = true;
    var elementGL = rendererGL.domElement;
    elementGL.style.position = 'absolute';
    elementGL.style.top = '0px';
    elementGL.style.width = '100%';
    elementGL.style.height = '100%';
    elementGL.style.pointerEvents = 'none';


    /** view-source:http://jeromeetienne.github.io/threex.htmlmixer/examples/basic.html */
    const DOMs = new THREEx.HtmlMixer.Context(rendererGL, sceneGL, camera);
    const rendererCSS = DOMs.rendererCss;
    rendererCSS.autoClear = false;
    rendererCSS.setClearColor(0x00ff00, 0.0);
    rendererCSS.gammaInput = true;
    rendererCSS.gammaOutput = true;


    var elementCSS = rendererCSS.domElement;
    elementCSS.style.position = 'absolute';
    elementCSS.style.top = '0px';
    elementCSS.style.width = '100%';
    elementCSS.style.height = '100%';
    view.appendChild(elementCSS);


    elementCSS.appendChild(elementGL);


    //mrdoob.com/lab/javascript/threejs/css3d/
    //groupCSS.add( DomSurface( 'http://fsf.org', 0, 0, - 240, Math.PI ) );
    //groupCSS.add(DomSurface('http://narchy.xyz', -240, 32, 0, -Math.PI / 2));

    // create the iframe element
    var url		=
        //'http://narchy.xyz/';
        '/index.html';
    var iframe	= document.createElement('iframe');
    iframe.src	= url;
    iframe.style.width = '480px';
    iframe.style.height = '360px';
    iframe.style.border	= 'none';

    // create the plane
    var mixerPlane	= new THREEx.HtmlMixer.Plane(DOMs, iframe);
    mixerPlane.object3d.scale.multiplyScalar(700);
    sceneGL.add(mixerPlane.object3d);


    const resizer = () => {
        const ww = window.innerWidth;
        const hh = window.innerHeight;
        camera.aspect = ww / hh;
        camera.updateProjectionMatrix();

        rendererGL.setSize(ww, hh);
        rendererCSS.setSize(ww, hh);
    };

    window.addEventListener('resize', resizer, false);

    resizer();
    animate();

    function initGUI() {

        var gui = new dat.GUI();


        gui.add(effectController, "showLines").onChange(function (value) {
            edgeMesh.visible = value;
        });
        gui.add(effectController, "minDistance", 10, 300);
        gui.add(effectController, "limitConnections");
        gui.add(effectController, "maxConnections", 0, 30, 1);
        gui.add(effectController, "particleCount", 0, maxParticleCount, 1).onChange(function (value) {

            particleCount = parseInt(value);
            nodes.setDrawRange(0, particleCount);

        });

    }


    /** https://github.com/mrdoob/three.js/blob/master/examples/css3d_youtube.html  */
    function DomSurface(url, x, y, z, ry) {
        var div = document.createElement('div');
        div.style.width = '480px';
        div.style.height = '360px';
        div.style.backgroundColor = '#000';
        var iframe = document.createElement('iframe');
        iframe.style.width = '480px';
        iframe.style.height = '360px';
        iframe.style.border = '0px';
        iframe.src = url;
        div.appendChild(iframe);


        var material = new THREE.MeshBasicMaterial({wireframe: true});
        var geometry = new THREE.PlaneGeometry();
        var planeMesh = new THREE.Mesh(geometry, material);
        sceneGL.add(planeMesh);


        var co = new THREE.CSS3DObject(div);

        co.position = planeMesh.position;
        co.rotation = planeMesh.rotation;

    }

    function update() {
        var vertexpos = 0;
        var colorpos = 0;
        var numEdges = 0;

        for (var i = 0; i < particleCount; i++)
            nodeData[i].arity = 0;

        for (var i = 0; i < particleCount; i++) {

            // get the particle
            var A = nodeData[i];

            const iii = i * 3;

            nodePos[iii] += A.vel.x;
            nodePos[iii + 1] += A.vel.y;
            nodePos[iii + 2] += A.vel.z;

            if (nodePos[iii + 1] < -rHalf || nodePos[iii + 1] > rHalf)
                A.vel.y = -A.vel.y;

            if (nodePos[iii] < -rHalf || nodePos[iii] > rHalf)
                A.vel.x = -A.vel.x;

            if (nodePos[iii + 2] < -rHalf || nodePos[iii + 2] > rHalf)
                A.vel.z = -A.vel.z;

            if (effectController.limitConnections && A.arity >= effectController.maxConnections)
                continue;

            const minDistanceSq = effectController.minDistance * effectController.minDistance;

            // Check collision
            for (var j = i + 1; j < particleCount; j++) {

                var B = nodeData[j];
                if (effectController.limitConnections && B.arity >= effectController.maxConnections)
                    continue;

                const jjj = j * 3;


                var distSq = 0;
                var dx = nodePos[iii] - nodePos[jjj];
                distSq += dx * dx;
                if (distSq > minDistanceSq) continue;
                var dy = nodePos[iii + 1] - nodePos[jjj + 1];
                distSq += dy * dy;
                if (distSq > minDistanceSq) continue;
                var dz = nodePos[iii + 2] - nodePos[jjj + 2];
                distSq += dz * dz;
                if (distSq > minDistanceSq) continue;


                A.arity++;
                B.arity++;

                var alpha = 1.0 - Math.sqrt(distSq) / effectController.minDistance;

                POS[vertexpos++] = nodePos[iii];
                POS[vertexpos++] = nodePos[iii + 1];
                POS[vertexpos++] = nodePos[iii + 2];

                POS[vertexpos++] = nodePos[jjj];
                POS[vertexpos++] = nodePos[jjj + 1];
                POS[vertexpos++] = nodePos[jjj + 2];

                COLOR[colorpos++] = alpha;
                COLOR[colorpos++] = alpha;
                COLOR[colorpos++] = alpha;

                COLOR[colorpos++] = alpha;
                COLOR[colorpos++] = alpha;
                COLOR[colorpos++] = alpha;

                numEdges++;

            }
        }


        edgeMesh.geometry.setDrawRange(0, numEdges * 2);
        edgeMesh.geometry.attributes.position.needsUpdate = true;
        edgeMesh.geometry.attributes.color.needsUpdate = true;

        //pointCloud.geometry.attributes.position.needsUpdate = true;

    }

    var lastTimeMsec= null;
    function animate(nowMsec){
        // keep looping

        // measure time
        lastTimeMsec	= lastTimeMsec || nowMsec-1000/60.0;
        const deltaMsec	= Math.min(200.0, nowMsec - lastTimeMsec);
        lastTimeMsec	= nowMsec;
        // call each update function

        const delta = (deltaMsec/1000);
        const now = nowMsec/1000;

        update();

        DOMs.update(delta, now)
        rendererGL.render(sceneGL, camera);

        requestAnimationFrame( animate );
    }

    requestAnimationFrame(animate);

</script>

</body>
</html>